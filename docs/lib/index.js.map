{"version":3,"file":"index.js","sources":["../../src/tools/index.js","../../src/components/EditableContent.js","../../src/components/EditableText.js","../../src/components/EditableData.js"],"sourcesContent":["export function getTextOffset(refNode, anchorNode, anchorOffset) {\n    const selection = document.getSelection()\n    const backupRange = selection.rangeCount > 0 && selection.getRangeAt(0)\n    const range = document.createRange()\n    range.setStart(refNode, 0)\n    range.setEnd(anchorNode, anchorOffset)\n    selection.removeAllRanges()\n    selection.addRange(range)\n    const length = selection.toString().length\n    selection.removeAllRanges()\n    if(backupRange)\n        selection.addRange(backupRange)\n    return length\n}\n\nexport function getNodeAtOffset(parentNode, textOffset) {\n    const getNext = (node, offset) => {\n        if((node.innerText || node.textContent).length >= offset) {\n            const children = node.childNodes\n            if(children.length < 1)\n                return { node, offset }\n            let offsetTemp = offset\n            let child\n            for(let i = 0; i < children.length; i++) {\n                child = children[i]\n                if((child.innerText || child.textContent).length >= offsetTemp)\n                    break\n                offsetTemp = offsetTemp - (child.innerText || child.textContent).length\n            }\n            return { node: child, offset: offsetTemp }\n        } else {\n            return { node: null, offset }\n        }\n    }\n\n    let current = getNext(parentNode, textOffset)\n\n    while(current.node && (current.node.nodeType !== 3 && current.node.childNodes.length > 0)) {\n        current = getNext(current.node, current.offset)\n    }\n\n    return current\n}\n\nexport function collapseRangeAt(node, offset) {\n    try {\n        document.getSelection().removeAllRanges()\n        const range = document.createRange()\n        range.setStart(node, offset)\n        range.setEnd(node, offset)\n        document.getSelection().addRange(range)\n    } catch(e) {\n        // silent\n    }\n}\n\n/**\n * Extract a mouse or touch position.\n */\nexport function extractPosition(event) {\n    if(event instanceof MouseEvent) {\n        return { x: event.clientX, y: event.clientY}\n    } else if(window['TouchEvent'] && event instanceof TouchEvent) {\n        return { x: event.changedTouches[0].clientX, y: event.changedTouches[0].clientY }\n    } else {\n        return {\n            x: event['clientX'] ? event['clientX'] : event['changedTouches'][0].clientX,\n            y: event['clientY'] ? event['clientY'] : event['changedTouches'][0].clientY\n        }\n    }\n}\n\n/**\n * Cross browser caret retrieveal @ mouse position.\n */\nexport function getCaret(event) {\n    let range, offset, node\n\n    let x, y = 0\n    if(!event['x']) {\n        const pos = extractPosition(event)\n        x = pos.x\n        y = pos.y\n    } else {\n        x = event['x']\n        y = event['y']\n    }\n\n    if(document.caretRangeFromPoint) {\n        range = document.caretRangeFromPoint(x, y)\n        node = range.startContainer\n        offset = range.startOffset\n    } else if(document['caretPositionFromPoint']) {\n        const position = document['caretPositionFromPoint'](x, y)\n        node = position['offsetNode']\n        offset = position['offset']\n        range = document.createRange()\n        range.setStart(node, offset)\n        range.setEnd(node, offset)\n    }\n\n    return { range, offset, node }\n}","import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\n\nimport {\n    getTextOffset,\n    getNodeAtOffset,\n    collapseRangeAt\n} from '../tools'\n\nexport class EditableContent extends Component {\n\n    static propTypes = {\n        children: PropTypes.node,\n        element: PropTypes.string,\n        uniqueKey: PropTypes.string,\n        disabled: PropTypes.bool\n    }\n\n    getSnapshotBeforeUpdate() {\n        const selection = document.getSelection()\n\n        if(\n            !this._elementRef ||\n            !selection.rangeCount ||\n            !this._elementRef.contains(selection.anchorNode)\n        ) {\n            return {}\n        }\n\n        const caretPosition = getTextOffset(\n            this._elementRef,\n            selection.anchorNode,\n            selection.anchorOffset\n        )\n\n        const caretPositionEnd =\n            this._elementRef.contains(selection.focusNode) &&\n            getTextOffset(\n                this._elementRef,\n                selection.focusNode,\n                selection.focusOffset\n            )\n\n        return {\n            caretPosition,\n            caretPositionEnd\n        }\n    }\n\n    componentDidUpdate(prevProps, prevState, { caretPosition, caretPositionEnd }) {\n        if(!this._elementRef || !caretPosition)\n            return\n\n        const { node, offset } = getNodeAtOffset(this._elementRef, caretPosition)\n\n        // console.log(node, offset)\n\n        if(!node)\n            return\n\n        if(!caretPositionEnd)\n            return collapseRangeAt(node, offset)\n\n        const { node: nodeEnd, offset: offsetEnd } = getNodeAtOffset(this._elementRef, caretPositionEnd)\n\n        if(!nodeEnd)\n            return collapseRangeAt(node, offset)\n\n        document.getSelection().removeAllRanges()\n        const range = document.createRange()\n        range.setStart(node, offset)\n        range.setEnd(nodeEnd, offsetEnd)\n        document.getSelection().addRange(range)\n    }\n\n    setRef = ref => {\n        this._elementRef = ref\n    }\n\n    onPaste = event => {\n        event.preventDefault()\n\n        const { clipboardData } = event\n\n        if(!clipboardData.types.includes('text/plain'))\n            return\n\n        const pastedText = clipboardData.getData('text/plain')\n        document.execCommand('insertText', false, pastedText)\n    }\n\n    render() {\n        const { children, element, uniqueKey, disabled, ...rest } = this.props\n        const Element = element || 'div'\n\n        return (\n            <Element\n                ref={ this.setRef }\n                contentEditable={ !disabled }\n                suppressContentEditableWarning\n                key={ uniqueKey || Math.random() }\n                onPaste={ this.onPaste }\n                style={{ whiteSpace: 'pre-wrap' }}\n                { ...rest }\n            >\n                { children }\n            </Element>\n        )\n    }\n}","import React, { PureComponent } from 'react'\nimport { EditableContent } from './EditableContent'\nimport PropTypes from 'prop-types'\n\nexport class EditableText extends PureComponent {\n\n    static propTypes = {\n        text: PropTypes.string.isRequired,\n        render: PropTypes.func.isRequired,\n        className: PropTypes.string,\n        onChange: PropTypes.func\n    }\n\n    update = event => {\n        const { onChange } = this.props\n        onChange(event.target.innerText)\n    }\n\n    render() {\n        const { text, render, className, ...rest } = this.props\n\n        const uniqueKey = text.length\n\n        return (\n            <EditableContent\n                className={ className }\n                onInput={ this.update }\n                uniqueKey={uniqueKey}\n                { ...rest }\n            >\n                { render(text) }\n            </EditableContent>\n        )\n    }\n}","import React, { PureComponent } from 'react'\nimport { EditableContent } from './EditableContent'\nimport { getTextOffset } from '../tools'\nimport PropTypes from 'prop-types'\n\nexport class EditableData extends PureComponent {\n\n    static propTypes = {\n        data: PropTypes.object.isRequired,\n        onChange: PropTypes.func.isRequired,\n        renderDataItem: PropTypes.func.isRequired,\n        helperRef: PropTypes.func\n\n    }\n\n    componentDidMount() {\n        const { helperRef } = this.props\n\n        helperRef(new DataHelper(this))\n    }\n\n    getDataNode(targetNode) {\n        let parent = targetNode\n        while(parent && (!parent.dataset || !parent.dataset.nodeIndex))\n            parent = parent.parentElement\n        return parent\n    }\n\n    update = () => {\n        const { data, onChange } = this.props\n\n        const nodes = Array.from(this._ref.querySelectorAll('[data-node]'))\n\n        if(nodes.length === 0 || nodes.length === 1 && !nodes[0].innerText) {\n            return onChange([{ text: this._ref.innerText }])\n        }\n\n        const newDataMap = nodes.reduce((acc, node, index) => {\n            let text = node.innerText\n            const parentNode = node.parentElement\n            const nodeIndex = node.dataset.nodeIndex\n\n            if(\n                index > 0 &&\n                parentNode.nodeType === 1 &&\n                parentNode !== this._ref &&\n                getComputedStyle(parentNode).display === 'block' &&\n                !node.previousSibling\n            ) {\n                text = '\\n' + text\n            }\n\n            const datum = {\n                ...data[nodeIndex] || {},\n                text\n            }\n\n            if(acc.has(nodeIndex)) {\n                let text = acc.get(nodeIndex).text\n                if(text.endsWith('\\n') && datum.text.startsWith('\\n')) {\n                    text += datum.text.substring(1)\n                } else {\n                    text += datum.text\n                }\n                acc.set(nodeIndex, {\n                    ...datum,\n                    text\n                })\n            } else {\n                acc.set(nodeIndex, datum)\n            }\n\n            return acc\n        }, new Map())\n\n        const newData =\n            Array.from(newDataMap)\n                .sort(([a], [b]) => a - b)\n                .map(([ , val ]) => {\n                    delete val.nodeIndex\n                    return val\n                })\n                .filter(item => item.text !== '\\n')\n\n        onChange(newData)\n    }\n\n    renderDataList = data => {\n        const { renderDataItem } = this.props\n\n        if(!data.length) {\n            return <span key={0} data-node data-node-index={0}><br/></span>\n        }\n\n        return data.map((item, index) =>\n            <span key={index} data-node data-node-index={index}>\n                { renderDataItem(item, index) }\n            </span>\n        )\n    }\n\n    render() {\n        // eslint-disable-next-line\n        const { data, className, renderDataItem, helperRef, ...rest } = this.props\n\n        const dataText = data.map(_ => _.text).join('')\n\n        return (\n            <EditableContent\n                className={ className }\n                onInput={ this.update }\n                uniqueKey={ dataText }\n                ref={ ref => this._ref = ref && ref._elementRef }\n                { ...rest }\n            >\n                { this.renderDataList(data) }\n            </EditableContent>\n        )\n    }\n}\n\nclass DataHelper  {\n\n    constructor(componentInstance) {\n        this.componentInstance = componentInstance\n    }\n\n    static updateNodes(data, targets, updateFunction) {\n        return data.reduce((acc, item, index) => {\n            const matchingTarget = targets.find(t => t.index === index)\n\n            if(!matchingTarget) {\n                acc.push(item)\n            } else {\n                if(matchingTarget.startOffset) {\n                    acc.push({\n                        ...item,\n                        text: item.text.substring(0, matchingTarget.startOffset)\n                    })\n                }\n                acc.push({\n                    ...updateFunction(item, matchingTarget, index, targets),\n                    text: item.text.substring(matchingTarget.startOffset || 0, matchingTarget.endOffset || item.text.length)\n                })\n                if(matchingTarget.endOffset) {\n                    acc.push({\n                        ...item,\n                        text: item.text.substring(matchingTarget.endOffset)\n                    })\n                }\n            }\n            return acc\n        }, [])\n    }\n\n    static defaultMerge(a, b) {\n        if(Object.keys(a).length !== Object.keys(b).length)\n            return false\n        return Object.keys(a).every(key => key === 'text' ? true : a[key] === b[key])\n    }\n\n    // Public\n\n    cleanNodes(nodes, mergeFunction = DataHelper.defaultMerge) {\n        return nodes\n            .filter(elt => !!elt && !!elt.text)\n            .reduce((acc, elt) => {\n                const previousElt = acc.length && acc[acc.length - 1]\n                if(mergeFunction(previousElt, elt)) {\n                    previousElt.text += elt.text\n                } else {\n                    acc.push(elt)\n                }\n                return acc\n            }, [])\n    }\n\n    getRef() {\n        return this.componentInstance._ref\n    }\n\n    /**\n     * Retrieves selected data nodes.\n     */\n    getSelection(expandWhenCollapsed = true) {\n        const { _ref, props: { data }} = this.componentInstance\n\n        const selection = document.getSelection()\n\n        if(!selection.rangeCount)\n            return\n\n        const range = document.getSelection().getRangeAt(0)\n\n        if(!_ref.contains(range.startContainer) || !_ref.contains(range.endContainer))\n            return\n\n        const selectionText = selection.toString()\n        let dataNode = range.startContainer\n\n        while(dataNode && (!dataNode.dataset || !dataNode.dataset.nodeIndex)) {\n            dataNode = dataNode.parentElement\n        }\n\n        if(!dataNode)\n            return\n\n        const backupRange = range.cloneRange()\n\n        const startOffset = getTextOffset(dataNode, range.startContainer, range.startOffset)\n        const endOffset = range.endOffset + startOffset - range.startOffset\n\n        selection.addRange(backupRange)\n\n        if(range.startContainer === range.endContainer || range.startContainer.contains(range.endContainer)) {\n            const index = parseInt(dataNode.dataset.nodeIndex, 10)\n            const doExpand = expandWhenCollapsed && range.collapsed\n\n            return [{\n                index,\n                text: doExpand ? dataNode.innerText : selectionText,\n                startOffset: doExpand ? null : startOffset,\n                endOffset: doExpand ? null : endOffset,\n                dataItem: data[index]\n            }]\n        } else {\n            const rangeNodes = range.cloneContents()\n            const dataNodes = Array.from(rangeNodes.querySelectorAll('[data-node]'))\n\n            return dataNodes.map((node, index) => ({\n                index: parseInt(node.dataset.nodeIndex, 10),\n                text: node.innerText,\n                startOffset: index === 0 ? startOffset : null,\n                endOffset: index === dataNodes.length - 1 ? endOffset : null,\n                dataItem: data[parseInt(node.dataset.nodeIndex, 10)]\n            })).filter(_ => _.text && (_.endOffset === null || _.endOffset > 0))\n        }\n    }\n    /**\n     * Updates all the data nodes currently selected.\n     *\n     * @param {*} updateFunction - Properties to update in the selected data items.\n     * @param {*} mergeFunction - Optional, specifies how to merge neighbours into a single item (usually when their properties are similar)\n     */\n    applyToSelection(updateFunction, mergeFunction, { expandWhenCollapsed = true } = {}) {\n        const { props: { data }} = this.componentInstance\n\n        const targets = this.getSelection(expandWhenCollapsed)\n\n        if(!targets || !targets.length)\n            return\n\n        return this.cleanNodes(\n            DataHelper.updateNodes(data, targets, updateFunction),\n            mergeFunction\n        )\n    }\n}"],"names":["getTextOffset","refNode","anchorNode","anchorOffset","selection","document","getSelection","backupRange","rangeCount","getRangeAt","range","createRange","setStart","setEnd","removeAllRanges","addRange","length","toString","getNodeAtOffset","parentNode","textOffset","getNext","node","offset","innerText","textContent","children","childNodes","offsetTemp","child","i","current","nodeType","collapseRangeAt","e","EditableContent","setRef","_elementRef","ref","onPaste","preventDefault","clipboardData","event","types","includes","pastedText","getData","execCommand","this","contains","focusNode","focusOffset","prevProps","prevState","caretPosition","caretPositionEnd","nodeEnd","offsetEnd","props","element","uniqueKey","disabled","rest","Element","React","Math","random","whiteSpace","Component","propTypes","PropTypes","string","bool","EditableText","update","_this","onChange","target","text","render","className","PureComponent","isRequired","func","EditableData","data","nodes","Array","from","_ref","querySelectorAll","newDataMap","reduce","acc","index","parentElement","nodeIndex","dataset","getComputedStyle","display","previousSibling","datum","has","get","endsWith","startsWith","substring","set","Map","sort","map","val","filter","item","renderDataList","renderDataItem","key","data-node","data-node-index","helperRef","DataHelper","targetNode","parent","dataText","_","join","_this2","object","componentInstance","mergeFunction","defaultMerge","elt","previousElt","push","expandWhenCollapsed","startContainer","endContainer","selectionText","dataNode","cloneRange","startOffset","endOffset","parseInt","doExpand","collapsed","rangeNodes","cloneContents","dataNodes","updateFunction","targets","cleanNodes","updateNodes","matchingTarget","find","t","a","b","Object","keys","every"],"mappings":"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"}